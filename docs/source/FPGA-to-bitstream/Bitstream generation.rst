Bitstream generation
====================

Generate Bitstream <-- Meta Data

User guide
----------

To generate the necessary materials to generate bitstream, run ``$FAB_ROOT/fabric_generator/fabric_gen_v3.py`` with the ``-GenBitstreamSpec`` flag.

With the FASM file generated by Nextpnr or VPR, you can run this command for bitstream generation.

.. code-block:: console

        python3 $FAB_ROOT/nextpnr/fabulous_v3/arch/bit_gen.py -genBitstream <fasm_file> meta_data_v3.txt <bitstream file>

+------------------+-----------------------------------------------------------------------+
| <fasm_file>      | the FASM file generated by Nextpnr or VPR in previous compilation     |
+------------------+-----------------------------------------------------------------------+
| <bitstream_file> | User can define the output binary file name with ``.bin`` format      |
+------------------+-----------------------------------------------------------------------+

Example
-------

The following are simple command-line to synthesis the netlist ``sequential_16bit`` into JSON netlist.

.. code-block:: console

        python3 bit_gen.py -genBitstream 16bit_sequential.fasm meta_data_v3.txt 16bit_sequential_output.bin

Changes in the primitives or adding new primitives
--------------------------------------------------

For a change in the primitives or adding new primitives, you should make sure the function ``genBitstreamSpec`` in ``fabric_gen_v3.py`` has correct dictionary map for all primitives configuration. Here is the example in FABulous version3, in ``LUT4`` netlist, there are 16 configuration bits for init values, 1 configuration bit ``FF`` for Flip-flop bypass switch, 1 configuration bit ``IOmux`` for carry input switch, 1 conifguration bit ``SET_NORESET`` for SET or RESET switch, which means there are 19 configuration bits for each LUT4 parameters setting.

.. code-block:: python

  def genBitstreamSpec(archObject: Fabric):
    .
    .
    .
    #Generate mapping dicts for bel types: 
    #The format here is that each BEL has a dictionary that maps a fasm feature to another dictionary that maps bits to their values
    #The lines generating the BEL maps do it slightly differently, just notating bits that should go high - this is translated further down
    #We do not worry about bitmasking here - that's handled in the generation
    #LUT4:
    LUTmap = {}
    LUTmap['INIT'] = 0
    for i in range(16):
        LUTmap["INIT[" + str(i) + "]"] = i
    LUTmap["FF"] = 16
    LUTmap["IOmux"] = 17
    LUTmap["SET_NORESET"] = 18
    BelMap["LUT4c_frame_config"] = LUTmap
    #LUT-MUX8
    MUX8map = {"c0":0, "c1":1}
    BelMap["MUX8LUT_frame_config"] = MUX8map
    #DSP
    MULADDmap = {}
    MULADDmap["A_reg"] = 0
    MULADDmap["B_reg"] = 1
    MULADDmap["C_reg"] = 2
    MULADDmap["ACC"] = 3
    MULADDmap["signExtension"] = 4
    MULADDmap["ACCout"] = 5
    BelMap["MULADD"] = MULADDmap
    #IOpad
    BelMap["IO_1_bidirectional_frame_config_pass"] = {}
    Config_accessmap = {}
    Config_accessmap["C_bit0"] = 0
    Config_accessmap["C_bit1"] = 1
    Config_accessmap["C_bit2"] = 2
    Config_accessmap["C_bit3"] = 3
    BelMap["Config_access"] = Config_accessmap
    #InPass
    InPassmap = {}
    InPassmap["I0_reg"] = 0
    InPassmap["I1_reg"] = 1
    InPassmap["I2_reg"] = 2
    InPassmap["I3_reg"] = 3
    BelMap["InPass4_frame_config"] = InPassmap
    #OutPass
    OutPassmap = {}
    OutPassmap["I0_reg"] = 0
    OutPassmap["I1_reg"] = 1
    OutPassmap["I2_reg"] = 2
    OutPassmap["I3_reg"] = 3
    BelMap["OutPass4_frame_config"] = OutPassmap
    #RegFile
    RegFilemap = {}
    RegFilemap["AD_reg"] = 0
    RegFilemap["BD_reg"] = 1
    BelMap["RegFile_32x4"] = RegFilemap

(to do)





